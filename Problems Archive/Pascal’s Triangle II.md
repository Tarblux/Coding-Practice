# Pascalâ€™s Triangle II

Problem: 119
Official Difficulty: easy
Feels Like : medium
My Understanding: Needs Review
Topic: array, dynamic programming
Link: https://leetcode.com/problems/pascals-triangle-ii/description/
Completed On : June 1, 2024
Last Review: June 1, 2024
Days Since Review: 2

## Problem

---

Given an integer `rowIndex`, return the `rowIndexth` (**0-indexed**) row of the **Pascal's triangle**.

In **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:

![https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

**Example 1:**

```
Input: rowIndex = 3
Output: [1,3,3,1]
```

**Example 2:**

```
Input: rowIndex = 0
Output: [1]
```

**Example 3:**

```
Input: rowIndex = 1
Output: [1,1]
```

**Constraints:**

- `0 <= rowIndex <= 33`

**Follow up:** Could you optimize your algorithm to use only `O(rowIndex)` extra space?

## My Solutions

---

```python
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:

        if rowIndex < 2:

            return [1,1] if rowIndex else [1]

        output = [1,1]

        for i in range(2, rowIndex + 1):

            curr = [1] * (i + 1)

            for j in range(1, i):

                curr[j] = output[j - 1] + output[j]

            output = curr
        return output
```

```python

```

## Optimal Solutions

---

### Problem Description

Given an integer `rowIndex`, return the rowIndex-th (0-indexed) row of the Pascal's Triangle.

### Example

```python
Input: rowIndex = 3
Output: [1,3,3,1]

Input: rowIndex = 0
Output: [1]

Input: rowIndex = 1
Output: [1,1]

```

### Explanation

Pascal's Triangle is a triangular array of the binomial coefficients. The entries in each row are the coefficients in the expansion of \((a + b)^n\), where \(n\) is the row index.

To construct the Pascal's Triangle:

- The first and last elements of each row are `1`.
- Each interior element is the sum of the two elements above it.

### Optimal Solution and Explanation

To find the rowIndex-th row of Pascal's Triangle, we can use an iterative approach. We start with the first row and build each subsequent row using the previous row.

### Steps:

1. Initialize the first row as `[1]`.
2. For each subsequent row up to rowIndex, generate the new row by adding pairs of adjacent elements from the previous row, with `1`s at both ends.
3. Return the final row.

### Python Code

Here's the Python code to achieve this:

```python
def getRow(rowIndex):
    row = [1]
    for _ in range(rowIndex):
        row = [x + y for x, y in zip([0] + row, row + [0])]
    return row

# Example usage
print(getRow(3))  # Output: [1, 3, 3, 1]
print(getRow(0))  # Output: [1]
print(getRow(1))  # Output: [1, 1]

```

### Explanation

1. **Initialization**:
    - Start with the first row: `row = [1]`.
2. **Iterate to Generate Rows**:
    - For each row up to rowIndex, generate the new row by summing adjacent elements from the previous row.
    - Use `zip` to pair elements with a shifted version of the row to handle the edge cases by adding zeros at the beginning and the end.
    - Example for rowIndex 3:
        - Row 0: `[1]`
        - Row 1: `[1, 1]` (generated by summing `[0, 1]` and `[1, 0]`)
        - Row 2: `[1, 2, 1]` (generated by summing `[0, 1, 2]` and `[1, 2, 1, 0]`)
        - Row 3: `[1, 3, 3, 1]` (generated by summing `[0, 1, 3, 3]` and `[1, 3, 3, 1, 0]`)
3. **Return the Final Row**:
    - After generating the desired row, return it.

### Time Complexity Analysis

- **Time Complexity**: `O(rowIndex^2)`
    - Generating each row takes `O(rowIndex)` time.
    - Since we generate `rowIndex` rows, the total time complexity is `O(rowIndex^2)`.

### Space Complexity Analysis

- **Space Complexity**: `O(rowIndex)`
    - We only use a single list to store the current row, so the space complexity is linear with respect to the rowIndex.

### Explain Like I'm Five (ELI5)

Imagine building a pyramid with blocks. Each block on a higher level rests on two blocks below it. You start with a single block on the top, then keep adding levels below it:

1. **Top Level**: Start with one block.
2. **Next Levels**: For each new level, place a block at the ends and fill the middle with blocks, each resting on two blocks from the level above.
3. **Build Each Row**: Continue this process until you reach the desired level.

By carefully placing each block based on the blocks above, you build the entire pyramid row by row until you reach the row you need.

## Notes

---

 

## Related Videos

---

[https://www.youtube.com/watch?v=k1DNTyal77I&pp=ygUUcGFzY2FsJ3MgdHJpYW5nbGUgSUk%3D](https://www.youtube.com/watch?v=k1DNTyal77I&pp=ygUUcGFzY2FsJ3MgdHJpYW5nbGUgSUk%3D)